# Operating System
-----

## 메모리 관리 전략
1. 교착상태(DeadLock)가 무엇이며, 4가지 조건은?
    * 데드락 : 다른 프로세스가 점유하고 있는 자원을 둘 이상의 프로세스가 서로 기다릴 때 무한 대기에 빠지는 상황
    * 발생조건
      * `상호 배제` : 한 번에 프로세스 하나만 해당 자원 사용 가능
      * `점유 대기` : 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점윻기 위해 대기하는 프로세스가 존재해야 함
      * `비선점` : 이미 할당된 자원을 강제로 뺏을 수 없음
      * `순환 대기` : 대기 프로세스의 집합이 순환 형태로 대기하고 있어야 함
    * 해결방법
      * 데드락이 발생하지 않도록 `예방`하기 
      * 데드락 발생 가능성을 인정하면서도 `회피`하기
      * 데드락 발생을 허용하지만 데드락을 `탐지하여 회복`하기

2. 외부 단편화와 내부 단편화
    * `내부 단편화`
      * 빈 메모리에서 필요한만큼 작업하고 아주 작은 공간이 남아서 다른 작업들이 사용하지 못하게 되는 경우
      * 해결
        * `세그멘테이션` 기법 : 가상메모리 사용, 내부 단편화 해결, 외부 단편화 존재
          * 가상메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할해서 메모리를 할당하여 실제 메모리 주소로 변환을 하게 됨
          * 세그먼트들의 크기가 다르기 때문에 메모리에 적재될 때 빈 공간을 찾아 할당
        * `메모리 풀`
          * 필요한 메모리 공간을 미리 할당받아 놓고 필요할 때마다 사용하고 반납하는 기법
          * 사용후 반납 => 외부 단편화 X
          * 필요한 크기만큼 할당 => 내부 단편화 X
          * 미리 할당 후 사용하지 않는 순간에도 계속 할당하기 때문에 메모리 누수가 있음

    * `외부 단편화`
      * 메모리에 남아있는 용량이 작업하기에 충분하지만, 실제로 그 작업을 받아들이지 못하는 경우
      * 해결
        * `압축` : 빈공간들을 한쪽으로 몰아서 큰 공간으로 만드는 작업
        * `페이징 기법` : 가상메모리 사용, 외부 단편화 해결, 내부 단편화 존재
          * 페이지 : 가상메모리를 같은 크기의 블록으로 나눈 것
          * 프레임 : RAM을 페이지와 같은 크기로 나눈 것
          * 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법
          * 페이지 단위를 작게하면 내부 단편화 문제도 해결할 수 있겠지만, page mapping 과정이 많아져서 효율이 떨어질 수 있음

3. 페이징 장점과 단점
    * 장점 : 외부 단편화 해결 / 페이지 공유 가능(메모리 공간 활용 효과적) / 페이지 보호 가능
    * 단점 : 페이지 테이블 사용으로 분할방식 대비 주소결속에서 오버헤드 발생(속도 저하) / 페이지 테이블의 메인메모리 저장으로 공간 낭비

-----

## 가상메모리
1. 가상메모리의 역할
    * 메모리가 실제 메모리보다 많아 보이게 하는 기술
    * 어떤 프로세스가 실행될 때 메모리에 해당 프로세스 전체가 올라가지 않더라도 실행이 가능하다는 점에 착안하여 고안
2. Demand Paging(요구 페이징)
3. Cache 메모리를 사용하는 이유
4. 페이징의 장점과 단점

-----

## 커널
1. 커널(Kenel)이란?
    * 하드웨어와 응용 프로그램 사이에서 인터페이스를 제공하여 응용 프로그램이 하드웨어에서부터 오는 자원을 관리하는 사용 할 수 있게 해주는 것
2. 커널 수준 스레드와 사용자 수준 스레드의 장점과 단점
3. 인터럽트가 필요한 이유와 언제 발생되는지
4. 시스템콜이란 무엇이며, 예시는?
5. 서브루틴과 시스템 콜의 차이

-----

## 추가
1. 부팅이란?
2. 파일 싯템이란?
3. 캐시와 레지스터의 차이점?