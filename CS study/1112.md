# Normalization
## 정규화의 목적
* 관계형 DB 설계에서 `중복을 최소화`하게 데이터를 구조화하는 프로세스
* 함수적 종속성을 이용해 연관성이 있는 속성들을 분류하고, 각 테이블들에서 이상현상이 생기지 않도록 하는 과정

## 정규화의 장단점
* 장점
  * DB 변경시 `이상 현상들이 발생하는 문제점을 해결할 수 있음`
  * DB 구조 확장 시 정규화된 DB 구조에서는 새로운 데이터 형의 추가로 인한 확장 시, 구조를 변경하지 않아도 되거나 일부만 변경해도 됨 => DB와 연동된 응용 프로그램에 최소한의 영향을 미침 => 응용 프로그램의 생명 연장
  * 사용자에게 DB 모델을 더욱 의미있게 제공
* 단점
  * 테이블의 분해로 인해 테이블 간 `연산이 많아짐 => 응답 시간 느려질 수 있음`
  * 조회하는 SQL 문장에서 조인이 많이 발생 => 성능저하 나타남
    * 이 때 반정규화를 적용하여 해결 가능

## 이상현상 (anomaly)
* 잘못 설계된 테이블로 삽입, 수정, 삭제 같은 데이터 조작시 발생하는 일
* 삽입 이상 : 새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제
* 갱신 이상 : 중복 튜플 중 일부만 변경해서 데이터가 불일치하게 되는 모순의 문제
* 삭제 이상 : 튜플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실의 문제

## 반정규화 (역정규화)
* 데이터 성능 향상을 위해서, 데이터 중복을 허용하고 조인을 줄이는 방법
  * 디스크 I/O 양이 많아서 조회 시 성능이 저하될 때
  * 테이블끼리의 경로가 멀어서 조인으로 인한 성능 저하가 예상될 때

* 정규화 => 정합성, 데이터 무결성 보장 / 테이블이 복잡해지고 조회에 대한 성능이 떨어질 수 있음 
  * 입력, 수정, 삭제 성능 향상
  * 조회 성능 좋아질 수도, 나빠질 수도
* 반정규화 => 테이블 단순화, 성능 향상 / 정합성, 데이터 무결성 보장 X
  * 의도적으로 중복 생성 => 조회 성능 향상
  * 중복적인 속성 => 입력, 수정, 삭제 성능 감소

* 기법
  * 테이블 병합 : 조인되는 경우가 많아서 테이블을 합치는 것이 성능 향상에 효율적일 경우
    * 1:1 관계 테이블 병합 / 1:M 관계 테이블 병합 / 슈퍼&서브 타입 관계 테이블 병합
  * 테이블 분할 : 테이블에서 특정 속성들만 집중적으로 접근할 경우 분할
    * 수직 분할 / 수평 분할
  * 테이블 추가 
    * 중복 테이블 추가 : 다른 업무거나 서버가 다른 경우 동일한 테이블 구조를 중복하여 원격조인을 제거해 성능 향상
    * 통계 테이블 추가 : SUM, AVG 등을 미리 수행해 자동 계산해둠으로써 조회 시 성능 향상
    * 이력 테이블 추가 : 마스터 테이블에 존재하는 레코드를 중복하여 이력 테이블에 존재하는 방법
    * 부분 테이블 추가 : 하나의 테이블의 전체 칼럼 중 자주 이용하는 칼럼들이 있을 때, 디스크 I/O를 줄이기 위해 해당 칼럼들을 모아 놓은 별도의 반정규화된 테이블

* 데이터의 중복을 피할 수 있는데 반정규화를 하는 이유
  * 데이터 조회 시, 디스크 I/O 양이 많아서 성능 저하
  * 테이블끼리 거리가 너무 멀어서 조인으로 인한 성능 저하가 예상
  * 컬럼을 계산해서 읽을 때 성능 저하가 예상
  * 정규화 이전의 문제였던 데이터 중복으로 이상현상이 발생할 수 있기 때문에 반정규화할 대상을 정확히 조사 후 사용해야 함
  * 정규화 수행 => 엔터티 개수 증가, 관계가 많아짐 => 여러 개의 조인이 걸려야 데이터를 가져오는 경우 발생 => 반정규화 고려

## 정규화 단계별 과정
* 릴레이션 - 테이블 : 같은 의미로 사용
  * 정보를 정리한 표
  * 릴레이션은 구조에 관한 이론을 강조하는 측면
  * 테이블은 구조보다 데이터를 강조하는 측면

* 정규형 : 정규화 된 정도
* 비공식적으로는 제 3정규형이 되었으면 정규화가 되었다고 말함

* 제 1 정규화 => 제 1 정규형
  * 테이블의 모든 속성 값이 더 이상 분해되지 않는 원자값을 갖도록 테이블을 분해하는 것
  * 진행 후에도 삽입 이상, 갱신 이상, 삭제 이상 발생

* 제 2 정규화 => 제 2 정규형
  * 제 1정규형 & 기본키가 아닌 속성이 기본키에 완전 함수 종속이 되도록 테이블을 분해하는 것
  * 완전 함수적 종속 : 속성집합 Y가 속성집합 X 전체에 대해서만 함수적으로 종속된 경우
  * 진행 후에도 삽입 이상, 갱신 이상, 삭제 이상 발생

* 제 3 정규화 => 제 3 정규혛ㅇ
  * 제 2정규형 & 기본키가 아닌 속성이 기본키에 비이행적으로 종속이 되도록 테이블을 분해하는 것
  * 이행적 함수 종석 : X, Y, Z에 대해 X -> Y && Y -> Z == X -> Z 성립

* BCNF 정규화 (Boyce and Codd Normal Form)
  * 제 3정규형 & 모든 결정자가 후보키가 되도록 테이블을 분해하는 것
  * 제 3정규형까지 모두 만족하더라도, 하나의 테이블에 여러 개의 후보키가 존재할 경우 이상 현상이 발생할 수 있음 => 해결하기 위해 더 엄격한 제약조건을 제시한 것이 BCNF


# RDMBS/NoSQL
## 관계형 DB (RDBMS)와 비관계형 DB (NoSQL) 
* RDBMS
  * 행과 열로 구성된 테이블과의 관계를 나타낼 때 사용
  * 특징
    * 트랜잭션 : 전체 트랜잭션이 하나의 단위로 기록 (실패 시 전체 롤백)
    * 정규화 : DB 설계 시 중복을 최소화해서 구조화하는 프로세스
  * 장점
    * 데이터 성능이 일반적으로 좋음 => 정렬, 탐색, 분류 빠름
    * 신뢰성 높음 => 데이터 무결성 보장
    * 정규화에 따른 갱신 비용 최소화
  * 단점 
    * 스키마 수정 어려움
    * 데이터베이스 부하를 분석하기 어려움
    * 빅데이터를 처리하는데 비효율적임
* NoSQL
  * RDBMS의 한계를 넘기 위해 만들어진 새로운 형태의 DB
  * 특징 
    * Key-Value 형식 지원
    * PK, FK, JOIN 등 관계를 정의하지 않음
    * 스키마에 대한 정의가 없음
  * 장점 
    * 대용량 데이터 처리에 효율적
    * 읽기 작업보다 쓰기 작업이 더 빠르고 RDBMS에 비해 성능 빠름
    * 최적화된 키 값 저장 기법 사용 => 응답 속도, 처리 효율 등 성능 뛰어남
    * 복잡한 데이터 구조를 표현할 수 있음
  * 단점
    * 쿼리 처리시 데이터를 파싱 후 연산을 해야함 => 큰 크기의 document를 다룰 때는 성능이 저하됨

## View
* 사용자에게 접근이 허용된 자료만 보여주기 위해서 하나 이상의 기본 테이블로부터 유도된 가상 테이블
* 특징  
  * 기본 테이블과 같은 형태의 구조를 사용
  * 물리적으로 구현 X
  * 필요한 데이터만 처리 가능 => 관리 용이, 명령문 간단
  * 뷰에 나타나지 않는 데이터를 안전하게 보호 가능
* 장점
  * 데이터의 논리적 독립성을 제공
  * 사용자의 데이터 관리를 간단하게 해줌
  * 접근 제어를 통한 자동 보안 제공
  * 복잡한 쿼리를 단순화해서 사용 가능
* 단점
  * 뷰의 정의를 변경할 수 없음
  * 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따름
  * 독립적인 인덱스를 가질 수 없음
* 사용하는 이유 : 보안에 유리하며, 자주 쓰는 쿼리문을 안 쓰고 테이블만 조회하면 됨

## NoSQL 사용이 적합한 상황
* 데이터 유형에 제한 없음 / 추가 가능 / 대용량 데이터 처리에 효율적 => `데이터의 구조가 거의 or 전혀 없는 대용량의 데이터를 저장하는 경우`
* 수평적으로 확장, 값싼 서버 증설 or 클라우드 서비스를 이용하는 확장 => `클라우드 컴퓨팅이나 저장공간을 최대한 활용하는 경우`
* 스키마에 대한 정의가 없음 => `빠르게 서비스를 구축하는 과정에서 데이터 구조를 자주 업데이트 하는 경우` 
